"""Demand models."""
from typing import Dict, Set


import csv
import datetime


from job import *


class Demand:
    """Abstract class modeling demand."""

    def __init__(self) -> None:
        self.t_min = None
        self.t = None
        pass

    def seek(self, t: datetime.datetime) -> None:
        """Set demand to time t."""
        raise NotImplemented

    def tick(self, dt: datetime.timedelta, conditions: Dict) -> Set:
        """Get new jobs released on interval [t, t + dt).

        Args:
            dt: interval time delta
            conditions: dictionary of environmental conditions

        Returns:
            Dictionary with keys (job ID) and values Job objects.
        """
        raise NotImplemented


class ReplayDemand(Demand):
    """ReplayDemand is generated by replaying past data from a real dataset.

    Args:
        path: path to CSV file containing past demand.
        loop: loop the demand if episode reaches its end.
    """

    def __init__(self, path: str, region, loop: bool = True) -> None:
        super().__init__()
        self.datefmt = '%Y-%m-%d %H:%M:%S'
        self.path = path
        self.csvfile = open(path, 'r')
        self.reader = csv.DictReader(self.csvfile)
        self.last = next(self.reader)
        self.t_min = datetime.datetime.strptime(self.last['pickup_time'], self.datefmt)
        self.t = self.t_min
        self.global_idx = 0
        self.region = region
        self.loop = loop

    def seek(self, t: datetime.datetime) -> None:
        """Set demand to time t."""
        if self.t > t:
            self.csvfile.seek(0)
            next(self.reader)
            self.t = self.t_min
            self.seek(t)
            return
        while self.t < t:
            self.last = next(self.reader)
            self.t = datetime.datetime.strptime(self.last['pickup_time'], self.datefmt)

    def tick(self, dt: datetime.timedelta, conditions: Dict = None) -> Set:
        """Get new jobs released on interval [t, t + dt).

        Args:
            dt: interval time delta
            conditions: dictionary of environmental conditions

        Returns:
            Dictionary with keys (job ID) and values Job objects.
        """
        jobs = set({})
        end = self.t + datetime.timedelta(seconds=dt)
        try:
            while self.t < end:
                self.last = next(self.reader)
                jobs.add(Job(self.last, job_id=self.global_idx, region=self.region))
                self.global_idx += 1
                self.t = datetime.datetime.strptime(self.last['pickup_time'], self.datefmt)
            return jobs
        except StopIteration:
            if self.loop:
                self.seek(self.t_min)
                return self.tick(dt, conditions)
            else:
                raise StopIteration

